/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * CoorDUI.java
 *
 * Created on 16-dic-2010, 17:07:12
 */

package mi.CoorD;
//import javax.swing.*;
import java.io.*;

/**
 *
 * @author 
 */
public class CoorDUI extends javax.swing.JFrame {
    // defino las variables que se usarán en todo el programa
    private static boolean ha_pulsado_play;
    private static boolean stop;
    //private static double time_sleep;
    private static boolean fase_de_pruebas = true;
    private static String saltoDeLinea = "\n";

    /** Creates new form CoorDUI */
    public CoorDUI() {
        initComponents();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        PLAY_ = new javax.swing.JButton();
        jSeparator1 = new javax.swing.JSeparator();
        jLabel4 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        jLabel6 = new javax.swing.JLabel();
        jSeparator2 = new javax.swing.JSeparator();
        jScrollPane1 = new javax.swing.JScrollPane();
        contenido_fichero_in = new javax.swing.JTextArea();
        jScrollPane2 = new javax.swing.JScrollPane();
        contenido_fichero_out = new javax.swing.JTextArea();
        jLabel7 = new javax.swing.JLabel();
        jLabel8 = new javax.swing.JLabel();
        jLabel9 = new javax.swing.JLabel();
        jLabel10 = new javax.swing.JLabel();
        punto1_Y = new javax.swing.JTextField();
        punto1_X = new javax.swing.JTextField();
        punto2_X = new javax.swing.JTextField();
        fichero_in = new javax.swing.JTextField();
        punto2_Y = new javax.swing.JTextField();
        fichero_out = new javax.swing.JTextField();
        CLEAN_ = new javax.swing.JButton();
        jLabel11 = new javax.swing.JLabel();
        jScrollPane3 = new javax.swing.JScrollPane();
        errores_comentarios = new javax.swing.JTextArea();
        pantalla_linea_actual = new javax.swing.JTextField();
        STOP = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jPanel1.setBorder(javax.swing.BorderFactory.createTitledBorder(null, "CoorD v1.0", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Tahoma", 1, 14), new java.awt.Color(14, 237, 146))); // NOI18N

        jLabel1.setFont(new java.awt.Font("Tahoma", 1, 12));
        jLabel1.setText("Fichero IN:");

        jLabel2.setFont(new java.awt.Font("Tahoma", 1, 12));
        jLabel2.setText("Fichero OUT:");

        PLAY_.setFont(new java.awt.Font("Tahoma", 1, 16));
        PLAY_.setForeground(new java.awt.Color(0, 153, 0));
        PLAY_.setText("PLAY");
        PLAY_.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                PLAY_ActionPerformed(evt);
            }
        });

        jLabel4.setFont(new java.awt.Font("Tahoma", 1, 12));
        jLabel4.setForeground(new java.awt.Color(235, 22, 22));
        jLabel4.setText("Ejecutando instrucción:");

        jLabel5.setFont(new java.awt.Font("Tahoma", 1, 12));
        jLabel5.setText("Contenido Fichero IN:");

        jLabel6.setFont(new java.awt.Font("Tahoma", 1, 12));
        jLabel6.setText("Contenido Fichero OUT:");

        contenido_fichero_in.setColumns(20);
        contenido_fichero_in.setRows(5);
        jScrollPane1.setViewportView(contenido_fichero_in);

        contenido_fichero_out.setColumns(20);
        contenido_fichero_out.setRows(5);
        jScrollPane2.setViewportView(contenido_fichero_out);

        jLabel7.setFont(new java.awt.Font("Tahoma", 1, 12));
        jLabel7.setText("1º Punto Eje X:");

        jLabel8.setFont(new java.awt.Font("Tahoma", 1, 12));
        jLabel8.setText("1º Punto Eje Y:");

        jLabel9.setFont(new java.awt.Font("Tahoma", 1, 12));
        jLabel9.setText("2º Punto Eje X:");

        jLabel10.setFont(new java.awt.Font("Tahoma", 1, 12));
        jLabel10.setText("2º Punto Eje Y:");

        punto2_X.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                punto2_XActionPerformed(evt);
            }
        });

        CLEAN_.setFont(new java.awt.Font("Tahoma", 1, 16));
        CLEAN_.setForeground(new java.awt.Color(153, 0, 153));
        CLEAN_.setText("CLEAN");
        CLEAN_.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                CLEAN_ActionPerformed(evt);
            }
        });

        jLabel11.setFont(new java.awt.Font("Tahoma", 1, 12));
        jLabel11.setText("Errores y comentarios:");

        errores_comentarios.setColumns(20);
        errores_comentarios.setRows(5);
        jScrollPane3.setViewportView(errores_comentarios);

        pantalla_linea_actual.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                pantalla_linea_actualActionPerformed(evt);
            }
        });

        STOP.setFont(new java.awt.Font("Tahoma", 1, 16));
        STOP.setForeground(new java.awt.Color(255, 0, 0));
        STOP.setText("STOP");
        STOP.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                STOPActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                .addGap(44, 44, 44)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addComponent(jLabel7)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(jLabel1)
                            .addComponent(jLabel8)))
                    .addComponent(jLabel2))
                .addGap(18, 18, 18)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                        .addComponent(fichero_out)
                        .addComponent(fichero_in, javax.swing.GroupLayout.DEFAULT_SIZE, 320, Short.MAX_VALUE))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(punto1_Y)
                            .addComponent(punto1_X, javax.swing.GroupLayout.DEFAULT_SIZE, 252, Short.MAX_VALUE))
                        .addGap(39, 39, 39)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(jLabel9)
                            .addComponent(jLabel10))
                        .addGap(18, 18, 18)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(punto2_Y)
                            .addComponent(punto2_X, javax.swing.GroupLayout.DEFAULT_SIZE, 251, Short.MAX_VALUE))))
                .addGap(18, 18, 18)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(CLEAN_, javax.swing.GroupLayout.PREFERRED_SIZE, 111, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(STOP, javax.swing.GroupLayout.PREFERRED_SIZE, 91, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addComponent(PLAY_, javax.swing.GroupLayout.PREFERRED_SIZE, 211, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(298, 298, 298))
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGap(173, 173, 173)
                .addComponent(jLabel4)
                .addGap(26, 26, 26)
                .addComponent(pantalla_linea_actual, javax.swing.GroupLayout.PREFERRED_SIZE, 395, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(599, Short.MAX_VALUE))
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jSeparator1, javax.swing.GroupLayout.DEFAULT_SIZE, 1027, Short.MAX_VALUE)
                .addGap(300, 300, 300))
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, jPanel1Layout.createSequentialGroup()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel5)
                            .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 283, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(11, 11, 11)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel6)
                            .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 371, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(28, 28, 28)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(jPanel1Layout.createSequentialGroup()
                                .addComponent(jLabel11)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 197, Short.MAX_VALUE))
                            .addComponent(jScrollPane3, javax.swing.GroupLayout.DEFAULT_SIZE, 334, Short.MAX_VALUE)))
                    .addComponent(jSeparator2, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 1027, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(300, 300, 300))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(punto1_X, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel7)
                            .addComponent(jLabel9)
                            .addComponent(punto2_X, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(jPanel1Layout.createSequentialGroup()
                                .addGap(18, 18, 18)
                                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(jLabel10)
                                    .addComponent(punto2_Y, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                            .addGroup(jPanel1Layout.createSequentialGroup()
                                .addGap(10, 10, 10)
                                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(punto1_Y, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(jLabel8))))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(fichero_in, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel1))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(fichero_out, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel2)))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(PLAY_, javax.swing.GroupLayout.PREFERRED_SIZE, 64, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(CLEAN_, javax.swing.GroupLayout.DEFAULT_SIZE, 43, Short.MAX_VALUE)
                            .addComponent(STOP, javax.swing.GroupLayout.DEFAULT_SIZE, 47, Short.MAX_VALUE))))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 11, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(pantalla_linea_actual, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel4))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jSeparator2, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel5)
                    .addComponent(jLabel6)
                    .addComponent(jLabel11))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane3, javax.swing.GroupLayout.DEFAULT_SIZE, 323, Short.MAX_VALUE)
                    .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                        .addComponent(jScrollPane2)
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 323, Short.MAX_VALUE)))
                .addContainerGap())
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, 1058, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, 592, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void PLAY_ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_PLAY_ActionPerformed
        // TODO add your handling code here:

        // Se marca el play como pulsado
        ha_pulsado_play = true;

        // Se recogen los puntos dados
        String punto_X1 = punto1_X.getText();
        String punto_X2 = punto2_X.getText();
        String punto_Y1 = punto1_Y.getText();
        String punto_Y2 = punto2_Y.getText();
        // Se recoge el TimeSleep dado
        //time_sleep = Double.parseDouble(sleep_time_sec.getText().replace(',', '.'));
        //errores_comentarios.append("El tiempo de sleep es: "+ time_sleep + saltoDeLinea);
        // Se obtienen las coordenadas de los puntos
        double[] coord_punto_X1 = extrae_coordenadas(punto_X1);
        double[] coord_punto_X2 = extrae_coordenadas(punto_X2);
        double[] coord_punto_Y1 = extrae_coordenadas(punto_Y1);
        double[] coord_punto_Y2 = extrae_coordenadas(punto_Y2);
        errores_comentarios.append("El punto_X1 es: "+ coord_punto_X1[0] + "    " + coord_punto_X1[1] + saltoDeLinea);
        errores_comentarios.append("El punto_X2 es: "+ coord_punto_X2[0] + "    " + coord_punto_X2[1] + saltoDeLinea);
        errores_comentarios.append("El punto_Y1 es: "+ coord_punto_Y1[0] + "    " + coord_punto_Y1[1] + saltoDeLinea);
        errores_comentarios.append("El punto_Y2 es: "+ coord_punto_Y2[0] + "    " + coord_punto_Y2[1] + saltoDeLinea);
        // Se obtienen los vectores unitarios de la nueva base
        double [] vector_unitario_X = extrae_vector_unitario(coord_punto_X1, coord_punto_X2);
        double [] vector_unitario_Y = extrae_vector_unitario(coord_punto_Y1, coord_punto_Y2);
        errores_comentarios.append("El vector unitario X es: " + vector_unitario_X[0] + "   " + vector_unitario_X[1]+ saltoDeLinea);
        errores_comentarios.append("El vector unitario Y es: " + vector_unitario_Y[0] + "   " + vector_unitario_Y[1]+ saltoDeLinea);
        // Se obtiene el desplazamiento (punto de corte) de los ejes
        double[] desplazamiento = punto_corte(coord_punto_X1, coord_punto_X2, coord_punto_Y1, coord_punto_Y2);
        errores_comentarios.append("El punto de corte es: " + desplazamiento[0] + "   " + desplazamiento[1] + saltoDeLinea);
        //errores_comentarios.update(null);
        

        // Se comprueba los ficheros de entrada y salida
        String name_file_IN = fichero_in.getText();
        String name_file_OUT = fichero_out.getText();
        FileReader file_IN;
        BufferedReader input = null;
        String cadena;
        FileWriter file_OUT;
        PrintWriter output = null;
        boolean fallo = false;
        boolean fallo_permiso_IN = false;
        boolean fallo_NoEncontrado_IN = false;
        boolean fallo_permiso_OUT = false;
        boolean fallo_NoEncontrado_OUT = false;
        boolean fallo_IO_OUT = false;

        // Comprobamos el fichero de entrada
        try{
            // Apertura del fichero_IN de texto (modo lectura)
            file_IN = new FileReader(name_file_IN);
            // ... con buffer para leer linea a linea
            input = new BufferedReader(file_IN);
        }catch (SecurityException securityException){
            fallo_permiso_IN = true;
            fallo = true;
        }catch (FileNotFoundException fileException){
            fallo_NoEncontrado_IN = true;
            fallo = true;
        }

        // Comprobamos el fichero de salida
        try{
            // Apertura del fichero_OUT de texto (modo escritura)
            file_OUT = new FileWriter(name_file_OUT);
            output = new PrintWriter(file_OUT);
        }catch (SecurityException securityException){
            fallo_permiso_OUT = true;
            fallo = true;
        }catch (FileNotFoundException fileException){
            fallo_NoEncontrado_OUT = true;
            fallo = true;
        }catch (IOException e1){
            fallo_IO_OUT = true;
            fallo = true;
        }

        // Comprobamos si hubo algun error
        if (fallo){
            // Le paso los errores a la salida de errores
            if (fallo_permiso_IN){
                errores_comentarios.append("No tiene permiso para leer el fichero de entrada" + saltoDeLinea);
            }
            if (fallo_NoEncontrado_IN){
                errores_comentarios.append("Error al acceder al fichero de entrada" + saltoDeLinea);
            }
            if (fallo_permiso_OUT){
               errores_comentarios.append("No tiene permiso para escribir en el fichero de salida" + saltoDeLinea);
            }
            if (fallo_NoEncontrado_OUT){
                errores_comentarios.append("Error al crear el fichero de salida" + saltoDeLinea);
            }
            if (fallo_IO_OUT){
                errores_comentarios.append("Error en I/O del fichero de salida" + saltoDeLinea);
            }
        }
       
        // Con esto ya estan barridos todos los fallos posibles de fichero!!!
        // Si no hay errores continua la ejecucion del programa
        if (!fallo){
            // Se muestra todo el contenido del fichero de entrada, linea a linea, de una vez
            try{
                //contenido_fichero_in.setText("");
                while ((cadena = input.readLine()) != null){
                    contenido_fichero_in.append(cadena + saltoDeLinea);
                }
                //se cierra el fichero de entrada
                input.close();
            }catch(IOException e1){
                // Todos los problemas fueron tratados anteriormente
            }
        

            // Ahora se corrigen las posiciones con la nueva base girada y desplazada
            try{
                // Apertura del fichero_IN de texto (modo lectura)
                file_IN = new FileReader(name_file_IN);
                // ... con buffer para leer linea a linea
                input = new BufferedReader(file_IN);
                // Se lee linea a linea
                double[] punto_sistema_nuevo;
                String[] argumentos;
                boolean es_posicion_absoluta, es_posicion_relativa;
                double coordenada_x, coordenada_y, coordenada_z;
                // Se escriben las nuevas órdenes en el fichero de salida y en la pantalla
                //output.println("100 sa");
                //contenido_fichero_out.append("100 sa" + saltoDeLinea);
                while ((cadena = input.readLine()) != null){
                    argumentos = cadena.split("\\s+", 4);
                    // Habra que comprobar la longitud de argumentos
                    //if (argumentos.length != 3 && argumentos.length != 4){
                    if (argumentos.length != 4 || cadena.startsWith("//")){
                        // Si fuera algo distinto de "m" y "r"
                        // o si fuera un comentario,
                        // se imprime directamente la linea
                        output.println(cadena);
                        contenido_fichero_out.append(cadena + saltoDeLinea);
                    }else{
                        // Estamos en el caso de "m" y "r"
                        es_posicion_absoluta = false;
                        es_posicion_relativa = false;
                        coordenada_x = Double.parseDouble(argumentos[0]);
                        coordenada_y = Double.parseDouble(argumentos[1]);
                        coordenada_z = Double.parseDouble(argumentos[2]);
                        // Comprobamos si la posicion es absoluta o relativa
                        if (argumentos[3].equalsIgnoreCase("m") || argumentos[3].equalsIgnoreCase("move")){
                            es_posicion_absoluta = true;
                        }
                        if (argumentos[3].equalsIgnoreCase("r")){
                            es_posicion_relativa = true;
                        }
                        double[] punto_sistema_antiguo = {coordenada_x, coordenada_y, coordenada_z};
                        String cadena_nueva;
                        // Ahora se corrigen las posiciones con la nueva base, si es absoluto
                        if (es_posicion_absoluta){
                            punto_sistema_nuevo = corrige_posicion_absoluta(punto_sistema_antiguo, vector_unitario_X, vector_unitario_Y, desplazamiento);
                            cadena_nueva = punto_sistema_nuevo[0] + " " + punto_sistema_nuevo[1] + " " + punto_sistema_nuevo[2] + " m";
                            // Se escriben las nuevas órdenes en el fichero de salida y en la pantalla
                            output.println(cadena_nueva);
                            contenido_fichero_out.append(cadena_nueva + saltoDeLinea);
                        }
                        // Si fuera relativa la posicion entonces se envía y se muestra la línea tal y como vino.
                        if (es_posicion_relativa){
                            punto_sistema_nuevo = corrige_posicion_relativa(punto_sistema_antiguo, vector_unitario_X, vector_unitario_Y, desplazamiento);
                            cadena_nueva = punto_sistema_nuevo[0] + " " + punto_sistema_nuevo[1] + " " + punto_sistema_nuevo[2] + " r";
                            output.println(cadena_nueva);
                            contenido_fichero_out.append(cadena_nueva + saltoDeLinea);
                        }
                    }
                }
                // se cierra el fichero de salida
                output.flush();
                output.close();
                //se cierra el fichero de entrada
                input.close();
            }catch(IOException e1){
                // no es necesario, nunca llegara
            }
        }
      
}//GEN-LAST:event_PLAY_ActionPerformed

    private static void sleep(int n_seconds){
        // Este es con espera activa
        /* long tiempo_inicial = System.currentTimeMillis();
        long segundos_transcurridos = 0;
        while(segundos_transcurridos < n_seconds){
            segundos_transcurridos = (System.currentTimeMillis() - tiempo_inicial) / 1000;
        } */
        // este es un sleep sin espera activa
        try{
            Thread.sleep(n_seconds * 1000);
        }catch(InterruptedException ie1){
            // No debería pasar nada aquí
        }
    }

    private double[] extrae_coordenadas(String punto){
        // Se separa por espacios el string de entrada
        String [] array = punto.split("\\s+", 2);
        // Se pasan los datos a formato de coordenadas "x.y"
        String coord_x_punto = array[0].replace(',', '.');
        String coord_y_punto = array[1].replace(',', '.');
        // Se pasan esas coordenadas a numeros double
        double coord_x = Double.parseDouble(coord_x_punto);
        double coord_y = Double.parseDouble(coord_y_punto);
        // Se devuelve esa coordenada como un array
        double [] coordenada = {coord_x, coord_y};
        return coordenada;  
    }

    private double[] extrae_vector_unitario(double[] coord_punto_1, double[] coord_punto_2){
        // Se restan los puntos (final - inicial, es decir, pto.2 - pto.1)
        double vector_en_x = coord_punto_2[0] - coord_punto_1[0];
        double vector_en_y = coord_punto_2[1] - coord_punto_1[1];
        double []vector = {vector_en_x, vector_en_y};
        // Ahora se lo hace unitario
        double modulo = Math.sqrt(Math.pow(vector[0], 2.0) + Math.pow(vector[1], 2.0));
        double []vector_unitario = {vector[0]/modulo, vector[1]/modulo};
        // Se devuelve el vector unitario
        return vector_unitario;
    }

    private double[] punto_corte(double[] coord_punto_X1, double[] coord_punto_X2,
                                double[] coord_punto_Y1, double[] coord_punto_Y2){
        // Se halla la pendiente de la recta "Eje X" (m1)
        double m1 = (coord_punto_X2[1] - coord_punto_X1[1]) / (coord_punto_X2[0] - coord_punto_X1[0]);
        errores_comentarios.append("La pendiente de la recta del EJE X es: " + m1 + saltoDeLinea);
        // Se halla el termino independiente de la recta "Eje X" (n1)
        double n1 = coord_punto_X2[1] - m1 * coord_punto_X2[0];
        errores_comentarios.append("El término independiente de la recta del EJE X es: " + n1 + saltoDeLinea);
        // Se halla la pendiente de la recta "Eje Y" (m2)
        double m2 = (coord_punto_Y2[1] - coord_punto_Y1[1]) / (coord_punto_Y2[0] - coord_punto_Y1[0]);
        errores_comentarios.append("La pendiente de la recta del EJE Y es: " + m2 + saltoDeLinea);
        // Se halla el termino independiente de la recta "Eje Y" (n2)
        double n2 = coord_punto_Y2[1] - m2 * coord_punto_Y2[0];
        errores_comentarios.append("El término independiente de la recta del EJE Y es: " + n2 + saltoDeLinea);
        // Ahora calculamos el punto de corte de ambas rectas
        double corte_en_x = (n2 - n1) / (m1 - m2);
        double corte_en_y = (n2*m1 - n1*m2) / (m1 - m2);
        double[]punto_corte = {corte_en_x, corte_en_y};
        return punto_corte;
    }

    // Nota: El método corrige posicion trabaja en 2D, por lo que añade 0 en el eje Z.
    private double[] corrige_posicion_absoluta(double[] punto_sistema_antiguo, 
            double[] vector_unitario_X, double[] vector_unitario_Y, double[] desplazamiento){
        // Le aplico el cambio de base (giro)
        double nuevo_x, nuevo_y;
        nuevo_x = punto_sistema_antiguo[0]*vector_unitario_X[0] + punto_sistema_antiguo[1]*vector_unitario_Y[0];
        nuevo_y = punto_sistema_antiguo[0]*vector_unitario_X[1] + punto_sistema_antiguo[1]*vector_unitario_Y[1];
        // Se le aplica el desplazamiento
        nuevo_x = nuevo_x + desplazamiento[0];
        nuevo_y = nuevo_y + desplazamiento[1];
        // Se añade la tercera dimensión (se queda igual) y se envía el nuevo punto
        double[] punto_corregido = {nuevo_x, nuevo_y, punto_sistema_antiguo[2]};
        return punto_corregido;
    }

    // Nota: El método corrige posicion trabaja en 2D, por lo que añade 0 en el eje Z.
    private double[] corrige_posicion_relativa(double[] punto_sistema_antiguo,
            double[] vector_unitario_X, double[] vector_unitario_Y, double[] desplazamiento){
        // Le aplico el cambio de base (giro)
        double nuevo_x, nuevo_y;
        nuevo_x = punto_sistema_antiguo[0]*vector_unitario_X[0] + punto_sistema_antiguo[1]*vector_unitario_Y[0];
        nuevo_y = punto_sistema_antiguo[0]*vector_unitario_X[1] + punto_sistema_antiguo[1]*vector_unitario_Y[1];
        // Se añade la tercera dimensión (se queda igual) y se envía el nuevo punto
        double[] punto_corregido = {nuevo_x, nuevo_y, punto_sistema_antiguo[2]};
        return punto_corregido;
    }

    private void punto2_XActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_punto2_XActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_punto2_XActionPerformed

    private void CLEAN_ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_CLEAN_ActionPerformed
        // Se pone todo los datos en blanco
        pantalla_linea_actual.setText("");
        contenido_fichero_in.setText("");
        contenido_fichero_out.setText("");
        errores_comentarios.setText("");
    }//GEN-LAST:event_CLEAN_ActionPerformed

    private void pantalla_linea_actualActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_pantalla_linea_actualActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_pantalla_linea_actualActionPerformed

    private void STOPActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_STOPActionPerformed
        // TODO add your handling code here:

        // Se marca el stop como pulsado
        stop = true;
        // se actualiza la linea de ejecucion a STOP
        pantalla_linea_actual.setText("Ha pulsado STOP.");
    }//GEN-LAST:event_STOPActionPerformed

    /**
    * @param args the command line arguments
    */
    public static void main(String args[]) throws InterruptedException {
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new CoorDUI().setVisible(true);
                // El código va aquí (opción 3)
            }
            // El código va aquí (opción 2)
        });
        
        // El código va aquí (opción 1)
        //Ahora se procede a ejecutar las ordenes "reales" del archivo de salida
        while(true){
            // Se comprobara una vez cada segundo para no consumir mucha CPU
            sleep(1);
            if(ha_pulsado_play){
                stop = false;
                try{
                    // Desmarca el pulsado_play
                    ha_pulsado_play = false;
                    // Apertura del fichero_IN de texto (modo lectura)
                    String name_file_OUT = fichero_out.getText();
                    FileReader file = new FileReader(name_file_OUT);
                    // ... con buffer para leer linea a linea
                    BufferedReader input_cmd = new BufferedReader(file);
                    // Se lee linea a linea
                    String linea, comando;
                    while ((linea = input_cmd.readLine()) != null){
                        if (fase_de_pruebas)
                            break;
                        if (!stop){
                            // Aqui se envia la orden a cmd!!!!
                            pantalla_linea_actual.setText(linea);
                            //pantalla_linea_actual.update(null);
                            comando = "cmd.exe /C echo" + linea +" > COM1";
                            // La siguiente linea es solo para comprobacion
                            errores_comentarios.append("El comando es: " + comando + saltoDeLinea);
                            // Si no esta en fase de pruebas(para testear facilmente), se manda al aparato
                            if (!fase_de_pruebas){
                                Runtime r = Runtime.getRuntime();
                                Process p = r.exec(comando);
                                //p.waitFor();
                            }
                            
                            // Se espera Sleep Time seconds
                            //sleep((int)time_sleep);
                        }
                    }
                    if (stop){
                        stop = false;
                    }
                    //se cierra el fichero de comandos
                    input_cmd.close();
                    // se actualiza la linea de ejecucion actual
                    pantalla_linea_actual.setText("Finalizado.");
                }catch(IOException e1){
                    // No es necesario, no ocurre esta excepcion
                }
            }
        }  
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton CLEAN_;
    private javax.swing.JButton PLAY_;
    private javax.swing.JButton STOP;
    public static javax.swing.JTextArea contenido_fichero_in;
    public static javax.swing.JTextArea contenido_fichero_out;
    public static javax.swing.JTextArea errores_comentarios;
    private javax.swing.JTextField fichero_in;
    private static javax.swing.JTextField fichero_out;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel11;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JSeparator jSeparator1;
    private javax.swing.JSeparator jSeparator2;
    private static javax.swing.JTextField pantalla_linea_actual;
    private javax.swing.JTextField punto1_X;
    private javax.swing.JTextField punto1_Y;
    private javax.swing.JTextField punto2_X;
    private javax.swing.JTextField punto2_Y;
    // End of variables declaration//GEN-END:variables

}
